--- a/net/minecraft/server/world/ThreadedAnvilChunkStorage.java	2023-03-30 19:29:27
+++ b/net/minecraft/server/world/ThreadedAnvilChunkStorage.java	2023-03-30 19:29:44
@@ -700,7 +700,7 @@
       if (!chunkHolder.isAccessible()) {
          return false;
       } else {
-         Chunk chunk = (Chunk)chunkHolder.getSavingFuture().getNow((Object)null);
+         Chunk chunk = (Chunk)chunkHolder.getSavingFuture().getNow(null);
          if (!(chunk instanceof ReadOnlyChunk) && !(chunk instanceof WorldChunk)) {
             return false;
          } else {
@@ -761,7 +761,7 @@
       } else {
          NbtCompound nbtCompound;
          try {
-            nbtCompound = (NbtCompound)((Optional)this.getUpdatedChunkNbt(pos).join()).orElse((Object)null);
+            nbtCompound = (NbtCompound)((Optional)this.getUpdatedChunkNbt(pos).join()).orElse(null);
             if (nbtCompound == null) {
                this.markAsProtoChunk(pos);
                return false;
@@ -845,14 +845,14 @@
          ChunkHolder chunkHolder = (ChunkHolder)entry.getValue();
          Optional<Chunk> optional = Optional.ofNullable(chunkHolder.getCurrentChunk());
          Optional<WorldChunk> optional2 = optional.flatMap((chunk) -> chunk instanceof WorldChunk ? Optional.of((WorldChunk)chunk) : Optional.empty());
-         csvWriter.printRow(chunkPos.x, chunkPos.z, chunkHolder.getLevel(), optional.isPresent(), optional.map(Chunk::getStatus).orElse((Object)null), optional2.map(WorldChunk::getLevelType).orElse((Object)null), getFutureStatus(chunkHolder.getAccessibleFuture()), getFutureStatus(chunkHolder.getTickingFuture()), getFutureStatus(chunkHolder.getEntityTickingFuture()), this.ticketManager.getTicket(l), this.shouldTick(chunkPos), optional2.map((chunk) -> chunk.getBlockEntities().size()).orElse(0), simulationDistanceLevelPropagator.getTickingTicket(l), simulationDistanceLevelPropagator.getLevel(l), optional2.map((chunk) -> chunk.getBlockTickScheduler().getTickCount()).orElse(0), optional2.map((chunk) -> chunk.getFluidTickScheduler().getTickCount()).orElse(0));
+         csvWriter.printRow(chunkPos.x, chunkPos.z, chunkHolder.getLevel(), optional.isPresent(), optional.map(Chunk::getStatus).orElse(null), optional2.map(WorldChunk::getLevelType).orElse(null), getFutureStatus(chunkHolder.getAccessibleFuture()), getFutureStatus(chunkHolder.getTickingFuture()), getFutureStatus(chunkHolder.getEntityTickingFuture()), this.ticketManager.getTicket(l), this.shouldTick(chunkPos), optional2.map((chunk) -> chunk.getBlockEntities().size()).orElse(0), simulationDistanceLevelPropagator.getTickingTicket(l), simulationDistanceLevelPropagator.getLevel(l), optional2.map((chunk) -> chunk.getBlockTickScheduler().getTickCount()).orElse(0), optional2.map((chunk) -> chunk.getFluidTickScheduler().getTickCount()).orElse(0));
       }
 
    }
 
    private static String getFutureStatus(CompletableFuture<Either<WorldChunk, ChunkHolder.Unloaded>> future) {
       try {
-         Either<WorldChunk, ChunkHolder.Unloaded> either = (Either)future.getNow((Object)null);
+         Either<WorldChunk, ChunkHolder.Unloaded> either = (Either)future.getNow(null);
          return either != null ? (String)either.map((chunk) -> "done", (unloaded) -> "unloaded") : "not completed";
       } catch (CompletionException var2) {
          return "failed " + var2.getCause().getMessage();
