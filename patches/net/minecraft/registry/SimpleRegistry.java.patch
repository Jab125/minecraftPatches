--- a/net/minecraft/registry/SimpleRegistry.java
+++ b/net/minecraft/registry/SimpleRegistry.java
@@ -124,23 +124,23 @@
       Validate.notNull(registryKey);
       Validate.notNull(object);
       if (this.idToEntry.containsKey(registryKey.getValue())) {
-         Util.throwOrPause((T)(new IllegalStateException("Adding duplicate key '" + registryKey + "' to registry")));
+         Util.throwOrPause(new IllegalStateException("Adding duplicate key '" + registryKey + "' to registry"));
       }
 
       if (this.valueToEntry.containsKey(object)) {
-         Util.throwOrPause((T)(new IllegalStateException("Adding duplicate value '" + object + "' to registry")));
+         Util.throwOrPause(new IllegalStateException("Adding duplicate value '" + object + "' to registry"));
       }
 
       RegistryEntry.Reference<T> reference;
       if (this.intrusiveValueToEntry != null) {
-         reference = (RegistryEntry.Reference)this.intrusiveValueToEntry.remove(object);
+         reference = this.intrusiveValueToEntry.remove(object);
          if (reference == null) {
             throw new AssertionError("Missing intrusive holder for " + registryKey + ":" + object);
          }
 
          reference.setRegistryKey(registryKey);
       } else {
-         reference = (RegistryEntry.Reference)this.keyToEntry.computeIfAbsent(registryKey, (key) -> RegistryEntry.Reference.standAlone(this.getEntryOwner(), key));
+         reference = this.keyToEntry.computeIfAbsent(registryKey, (key) -> RegistryEntry.Reference.standAlone(this.getEntryOwner(), key));
       }
 
       this.keyToEntry.put(registryKey, reference);
@@ -179,7 +179,7 @@
 
    @Nullable
    public T get(@Nullable RegistryKey<T> key) {
-      return getValue((RegistryEntry.Reference)this.keyToEntry.get(key));
+      return (T) getValue((RegistryEntry.Reference)this.keyToEntry.get(key));
    }
 
    @Nullable
@@ -353,8 +353,8 @@
          LOGGER.warn("Not all defined tags for registry {} are present in data pack: {}", this.getKey(), set.stream().map((tag) -> tag.id().toString()).sorted().collect(Collectors.joining(", ")));
       }
 
-      Map<TagKey<T>, RegistryEntryList.Named<T>> map2 = new IdentityHashMap(this.tagToEntryList);
-      tagEntries.forEach((tag, entries) -> ((RegistryEntryList.Named)map2.computeIfAbsent(tag, this::createNamedEntryList)).copyOf(entries));
+      Map<TagKey<T>, RegistryEntryList.Named<T>> map2 = new IdentityHashMap<>(this.tagToEntryList);
+      tagEntries.forEach((tag, entries) -> map2.computeIfAbsent(tag, this::createNamedEntryList).copyOf(entries));
       map.forEach(RegistryEntry.Reference::setTags);
       this.tagToEntryList = map2;
    }
